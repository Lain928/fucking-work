# 常见知识点总结
## 1.指针和引用的区别：
	（1）指针相当于存储地址的变量，只响内存的一个存储单元
		引用是变量的别名，在内存中占用相同的位置
	（2）指针可以为空，可以进行重新赋值；
		引用不可以为空，创建时必须进行初始化，且初始化后不能改变了
	（3）指针可以使用const修饰，引用不可以
	（4）指针可以有多级，引用只能是一级
	（5）sizeof函数：引用得到的是变量的大小，指针得到的是指针本身的大小
	（6）指针和引用的自增（++）运算符意义不一样
	（7）作为函数参数进行传递时有区别
		当把指针作为参数进行传递时，是将实参的一个拷贝传递给形参
		引用作为函数参数进行传递时，实质上传递的是实参本身，即传递进来的不是实参的一个拷贝
	
# 一、c++类的相关操作
## 1.构造函数和析构函数是否可以为虚函数？
	答：构造函数不能，析构函数可以
	（1）构造函数：虚函数的调用需要虚函数表指针，而该指针存放在对象的内存空间中；
	若构造函数声明为虚函数，那么由于对象还未创建，还没有内存空间，更没有虚函数表地址用来调用虚函数——构造函数了
	（2）析构函数：
	首先析构函数可以为虚函数，而且当要使用基类指针或引用调用子类时，最好将基类的析构函数声明为虚函数，否则可以存在内存泄露的问题。
	举例说明：
	子类B继承自基类A；A *p = new B; delete p;
	1） 此时，如果类A的析构函数不是虚函数，那么delete p；将会仅仅调用A的析构函数，只释放了B对象中的A部分，而派生出的新的部分未释放掉。
	2） 如果类A的析构函数是虚函数，delete p; 将会先调用B的析构函数，再调用A的析构函数，释放B对象的所有空间。
	补充： B *p = new B; delete p;时也是先调用B的析构函数，再调用A的析构函数。
	
	
# 二、c++模板
## 1.函数模板
	声明：
		template <typename T>
		void test(t a)
		{
			cout << a << endl;
		}
	应用：
		int main()
		{
			int a = 0;
			test(a); //自动调用
			test<int>(a); //显示调用
		}
## 2.类模板
	定义：
		template <class T>
		class Stack { 
		  private: 
			vector<T> elems;     // 元素 
		 
		  public: 
			void push(T const&);  // 入栈
			} 
		};
	声明类函数：
		template <class T>
		void Stack<T>::push (T const& elem) 
		{ 
			// 追加传入元素的副本
			elems.push_back(elem);    
		}
	应用:
		Stack<int> intStack;  // int 类型的栈 
		Stack<string> stringStack;    // string 类型的栈 
	

# 三、STL相关库操作
## 1.vector的赋值相关操作
	(1)不可以直接使用“=”进行赋值，因为未重载”=“操作，应使用vector<elem> b(a);

